---
alwaysApply: true
---
This rule provides guidance to AI coding assistants when working in this repository.

## Repository Overview

This is a monorepo with two main applications:

- `apps/frontend/` - Vite + React + TypeScript UI (shadcn-ui, Tailwind)
- `apps/backend/` - Express + TypeScript API server

Root workspace uses npm workspaces. Entry points:

- Frontend: [`apps/frontend/src/main.tsx`](mdc:apps/frontend/src/main.tsx)
- Backend: [`apps/backend/index.ts`](mdc:apps/backend/index.ts) via [`apps/backend/app.ts`](mdc:apps/backend/app.ts)

Backend exposes endpoints under `/api/*` mounted in `app.ts`:
- `/api/practice-room` – room creation and updates
- `/api/practice-round` – round creation and updates
- `/api/profile` – profile creation and updates
- `/api/recording` – start/stop recording
- `/api/assessment` – run assessment
- `/api/health` – health check

Authentication: Backend middleware in [`apps/backend/utils/supabase.ts`](mdc:apps/backend/utils/supabase.ts) validates requests using Supabase access tokens via the `Authorization: Bearer <token>` header. Frontend attaches the token in an Axios interceptor.

Context Provider: `AuthProvider` (`apps/frontend/src/supabase/AuthProvider.tsx`) is mounted in `apps/frontend/src/App.tsx` and exposes via `useAuth()` the following: `user`, `session`, `loading`, `userProfile`, `reloadProfile()`, and `signOut()`. 
- `user?.id` is leveraged frequently in components when calling data helpers (e.g., `fetchRoundsByCandidate(user.id)`), and show fallback UI if `!user`.
- Use `signOut()` for logout flows.

State Management: The app currently manages state with `useState`/`useEffect` and Supabase Realtime subscriptions (`subscribeToAllPracticeRooms`, `subscribeToPracticeRoomByRoomId`, `subscribeToPracticeRoundsByRoomId`) alongside direct reads (`fetchAllRooms`, `fetchRoomWithProfiles`, `fetchRoundsByCandidate`, `fetchCaseBriefs`). Writes go through `apps/frontend/src/lib/api.ts` (Axios with Supabase access token attached). Prefer local component state and explicit effects/subscriptions; adopt React Query for future caching/invalidation or where data dependencies become complex.

DB use in backend vs frontend: Frontend reads simple lists/details directly from Supabase using the typed client. All writes and multi-service workflows (rooms/rounds/profile updates, recording, transcription, assessment) go through the backend Express API, which authenticates and uses a token-scoped Supabase client (`req.supabaseAsUser`) to honor RLS and encapsulate business logic.

## User Flow and Services

- Interview Scheduling and Acceptance: See detailed rule: [`USER_FLOW_SCHEDULING`](mdc:.cursor/rules/USER_FLOW_SCHEDULING.mdc). Host creates rooms, guests accept invites; lists and details update via Supabase reads and realtime.
- Interview Room: See detailed rule: [`USER_FLOW_ROOM`](mdc:.cursor/rules/USER_FLOW_ROOM.mdc). Covers stage transitions, rounds, candidate/case assignment, and realtime synchronization.
- Recording, Transcription, and Assessment: See detailed rule: [`USER_FLOW_RTA`](mdc:.cursor/rules/USER_FLOW_RTA.mdc). Single action triggers recording lookup, transcription, and Gemini assessment persisted on `practice_rounds`.

## Available Tools
- The Supabase MCP server should be used to understand the database schema and policies to ensure plans and implementation take account of these
- Project documents such as PRDs, implementation plans and implementation trackers are used for each feature, make sure to update these with any necessary deviations from the plan identified whilst carrying out implementation and also update the tracker with progress.

## TypeScript & Linting

- Strict TypeScript across apps
- ESLint config in [`apps/frontend/eslint.config.js`](mdc:apps/frontend/eslint.config.js)
- Node >= 20 required at root and backend

## Additional Notes

- Project purpose and onboarding: [`README.md`](mdc:README.md)
- Backend notes: [`apps/backend/README.md`](mdc:apps/backend/README.md)

## Architectural Conventions

- Business logic belongs in services, not in routes or repositories.
  - Routes should remain thin: parse/validate input, authenticate, call a service, translate errors to HTTP status codes.
  - Repositories are persistence-only (CRUD with mapping). They must not embed business rules.
  - Services enforce domain rules (e.g., booking guards, role checks) and orchestrate repository calls.

- Shared types over inline types.
  - Prefer importing shared TypeScript types from `apps/backend/types/index.ts` (e.g., `PracticeRoomUpdate`) instead of defining inline ad-hoc shapes in routes or services.
  - Keep mappers in `types/index.ts` the single source of truth for DB <-> domain conversions.
  - On the frontend, prefer importing domain/view types from `apps/frontend/src/types/index.ts` (e.g., `PracticeRoomWithProfiles`) instead of re-declaring shapes in components or hooks.

- Error handling
  - Use central error utilities (e.g., `HttpError`) to carry HTTP status codes from services to routes.
  - Backend services should throw `HttpError(status, message)` from `apps/backend/utils/httpError.ts`; routes must catch it and respond with `res.status(err.status).json({ error: err.message })`. Do not put business-logic status mapping in repositories.
  - Frontend must centralize repeated API error mapping via `mapApiError(err, context)` in `apps/frontend/src/lib/utils.ts` to keep components lean and consistent.
    - Supported contexts: `'booking' | 'reschedule' | 'cancel' | 'round' | 'recording' | 'assessment' | 'profile' | 'generic'`.
    - Standard mappings:
      - 400 → Invalid request (e.g., reschedule: "Please select a valid future date/time.")
      - 401 → Session expired → prompt sign-in
      - 403 → Not allowed (context-specific description)
      - 404 → Not found
      - 409 → Conflict (booking: "Already booked"; recording: state prevents action; otherwise generic conflict)
      - 5xx → Server/provider error with retry-friendly copy

## Database Types Generation

- When the database schema changes, regenerate TS database types for both apps using the root script:
  - `npm run generate:types`
- This updates `apps/frontend/src/types/database.types.ts` and `apps/backend/types/database.types.ts`. Commit both files with schema changes.

